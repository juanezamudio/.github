name: Update Current Projects

on:
  schedule:
    - cron: "0 0 * * *" # Runs daily at midnight UTC
  workflow_dispatch: # Allows manual trigger

permissions:
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Update Current Projects with AI
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          node << 'EOF'
          const fs = require('fs');

          async function fetchReadmeContent(owner, repoName, token) {
            try {
              // Fetch README content from GitHub API
              const response = await fetch(`https://api.github.com/repos/${owner}/${repoName}/readme`, {
                headers: {
                  'Authorization': `token ${token}`,
                  'Accept': 'application/vnd.github.v3.raw'
                }
              });
              if (response.ok) {
                const content = await response.text();
                // Truncate to first 1500 chars to keep API costs low
                return content.slice(0, 1500);
              }
              return null;
            } catch (e) {
              console.log(`Could not fetch README for ${repoName}:`, e.message);
              return null;
            }
          }

          async function fetchRecentCommits(owner, repoName, token) {
            try {
              const response = await fetch(`https://api.github.com/repos/${owner}/${repoName}/commits?per_page=5`, {
                headers: { 'Authorization': `token ${token}` }
              });
              if (response.ok) {
                const commits = await response.json();
                return commits.map(c => c.commit.message.split('\n')[0]).slice(0, 5);
              }
              return [];
            } catch (e) {
              return [];
            }
          }

          async function main() {
            const owner = 'juanezamudio';
            const token = process.env.GITHUB_TOKEN;

            // Fetch recent repos from GitHub API
            const reposResponse = await fetch(`https://api.github.com/users/${owner}/repos?sort=pushed&direction=desc&per_page=15`, {
              headers: { 'Authorization': `token ${token}` }
            });
            const allRepos = await reposResponse.json();

            // Filter out certain repos
            const excludeRepos = ['.github', 'dotfiles', 'juanezamudio', 'github-readme-stats', 'github-profile-trophy'];
            const recentRepos = allRepos
              .filter(repo => !excludeRepos.includes(repo.name) && !repo.fork)
              .slice(0, 4);

            console.log('Processing repos:', recentRepos.map(r => r.name));

            // Fetch detailed info for each repo (README + recent commits)
            const repoDetails = await Promise.all(recentRepos.map(async (repo) => {
              const [readme, commits] = await Promise.all([
                fetchReadmeContent(owner, repo.name, token),
                fetchRecentCommits(owner, repo.name, token)
              ]);
              return {
                name: repo.name,
                description: repo.description || 'No description provided',
                language: repo.language || 'Unknown',
                url: repo.html_url,
                topics: repo.topics || [],
                readme: readme || 'No README available',
                recentCommits: commits
              };
            }));

            console.log('Fetched details for repos');

            // Call Gemini API with rich context
            const prompt = `You are helping update a GitHub profile README's "Currently Working On" section.

For each repository below, I'm providing the README content and recent commits so you can understand what the project actually does.

Generate for each repo:
1. A single relevant emoji that best represents the project's purpose
2. A concise but informative description (15-25 words) that accurately describes what the project does and its current state

REPOSITORIES:
${repoDetails.map(r => `
--- ${r.name} ---
Language: ${r.language}
Topics: ${r.topics.join(', ') || 'None'}
Original Description: ${r.description}
Recent Commits: ${r.recentCommits.join(' | ') || 'None'}
README Preview:
${r.readme}
`).join('\n')}

Respond in JSON format only, no markdown code blocks:
[{"name": "repo-name", "emoji": "ðŸ”¨", "description": "A detailed description based on the README content"}, ...]`;

            const geminiResponse = await fetch(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=${process.env.GEMINI_API_KEY}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  contents: [{ parts: [{ text: prompt }] }],
                  generationConfig: { temperature: 0.5 }
                })
              }
            );

            const geminiData = await geminiResponse.json();
            let aiOutput;

            try {
              const responseText = geminiData.candidates[0].content.parts[0].text;
              // Clean up potential markdown formatting
              const cleanJson = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
              aiOutput = JSON.parse(cleanJson);
              console.log('AI output:', aiOutput);
            } catch (e) {
              console.log('AI parsing failed, using fallback:', e.message);
              console.log('Raw response:', JSON.stringify(geminiData, null, 2));
              // Fallback to basic emoji mapping
              aiOutput = recentRepos.map(repo => ({
                name: repo.name,
                emoji: 'ðŸ”¨',
                description: repo.description || `Working on ${repo.name.replace(/-/g, ' ')}`
              }));
            }

            // Build the new section content
            let newSection = '## ðŸ”­ Currently Working On\n\n';
            for (const repo of recentRepos) {
              const aiRepo = aiOutput.find(r => r.name === repo.name) || { emoji: 'ðŸ”¨', description: repo.description || repo.name };
              newSection += `- ${aiRepo.emoji} [**${repo.name}**](${repo.html_url}) â€” ${aiRepo.description}\n`;
            }

            // Read and update README
            const readmePath = 'README.md';
            let readme = fs.readFileSync(readmePath, 'utf8');
            const sectionRegex = /## ðŸ”­ Currently Working On\n\n[\s\S]*?(?=\n---|\n## )/;
            readme = readme.replace(sectionRegex, newSection);
            fs.writeFileSync(readmePath, readme);

            // Also update profile/README.md
            const profileReadmePath = 'profile/README.md';
            if (fs.existsSync(profileReadmePath)) {
              let profileReadme = fs.readFileSync(profileReadmePath, 'utf8');
              profileReadme = profileReadme.replace(sectionRegex, newSection);
              fs.writeFileSync(profileReadmePath, profileReadme);
            }

            console.log('README updated successfully!');
          }

          main().catch(console.error);
          EOF

      - name: Commit and push if changed
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add -A
          git diff --quiet && git diff --staged --quiet || (git commit -m "ðŸ¤– Update current projects with AI" && git pull --rebase && git push)
